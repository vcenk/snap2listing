<!DOCTYPE html>
<html>
<head>
    <title>WebGL Texture Orientation Test</title>
    <style>
        body { font-family: Arial; padding: 20px; }
        canvas { border: 2px solid #000; margin: 10px; }
        .test { margin: 20px 0; }
    </style>
</head>
<body>
    <h1>WebGL Texture Orientation Test</h1>

    <div class="test">
        <h2>Original Image</h2>
        <canvas id="original" width="200" height="200"></canvas>
    </div>

    <div class="test">
        <h2>WebGL with flipY: false (Current Fix)</h2>
        <canvas id="webgl-no-flip" width="200" height="200"></canvas>
    </div>

    <div class="test">
        <h2>WebGL with flipY: true (Old Behavior)</h2>
        <canvas id="webgl-flip" width="200" height="200"></canvas>
    </div>

    <script>
        // Create test image with arrow
        function createTestImage() {
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 200;
            const ctx = canvas.getContext('2d');

            // White background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, 200, 200);

            // Draw arrow pointing UP
            ctx.fillStyle = 'black';
            ctx.font = '60px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('â†‘', 100, 100);

            // Add "TOP" text
            ctx.font = '20px Arial';
            ctx.fillText('TOP', 100, 30);

            return canvas;
        }

        // Render to WebGL
        function renderWebGL(canvasId, flipY) {
            const canvas = document.getElementById(canvasId);
            const gl = canvas.getContext('webgl2');

            if (!gl) {
                console.error('WebGL2 not supported');
                return;
            }

            // Vertex shader
            const vsSource = `#version 300 es
                in vec2 aPosition;
                in vec2 aTexCoord;
                out vec2 vTexCoord;
                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);
                    vTexCoord = aTexCoord;
                }
            `;

            // Fragment shader
            const fsSource = `#version 300 es
                precision highp float;
                uniform sampler2D uTexture;
                in vec2 vTexCoord;
                out vec4 fragColor;
                void main() {
                    fragColor = texture(uTexture, vTexCoord);
                }
            `;

            // Compile shaders
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, vsSource);
            gl.compileShader(vs);

            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, fsSource);
            gl.compileShader(fs);

            // Link program
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            gl.useProgram(program);

            // Create geometry
            const vertices = new Float32Array([
                -1, -1, 0, 0,  // bottom-left
                 1, -1, 1, 0,  // bottom-right
                 1,  1, 1, 1,  // top-right
                -1,  1, 0, 1   // top-left
            ]);

            const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);

            const vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const ibo = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            const posLoc = gl.getAttribLocation(program, 'aPosition');
            const texLoc = gl.getAttribLocation(program, 'aTexCoord');

            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);

            gl.enableVertexAttribArray(texLoc);
            gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 16, 8);

            // Create texture
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            // THIS IS THE KEY LINE
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);

            const testImage = createTestImage();
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, testImage);

            // Render
            gl.clearColor(1, 1, 1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }

        // Draw original
        const originalCanvas = document.getElementById('original');
        const testImage = createTestImage();
        originalCanvas.getContext('2d').drawImage(testImage, 0, 0);

        // Test both flip modes
        renderWebGL('webgl-no-flip', false);
        renderWebGL('webgl-flip', true);

        console.log('Test complete. Compare the three canvases:');
        console.log('1. Original should show arrow pointing UP with "TOP" at top');
        console.log('2. WebGL no-flip should match original');
        console.log('3. WebGL flip should be upside down');
    </script>
</body>
</html>
